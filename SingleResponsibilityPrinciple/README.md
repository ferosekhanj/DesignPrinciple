# Single Responsibility Principle

- A class or module should have only one resposibility
- A class or module should have only one reason for change.

# Milkman

We would like to help our milkman in delivery.

# Features

## Step 1
- Each house in the street provides the number of milk packs needed.
- Our Milkman in the morning delivers the order to each house.

## Step 2
- We are delivering 3 different type of milk
- Cow, Goat & Soya
- House can choose the milk type
  
## Step 3
- A house can order a combination of milk daily.

## Step 4
- we added a new milk variety camel milk
- we are discontinuing the vegan milk
- we are expanding our business and would like to deliver Choclates and Biscut orders with the milk

## Step 5
- We are switching to a prepaid model, before delivery, the milk man checks whether there is enough money available in the customer wallet. If balance is less then no delivery is made. 

## Step 6
- We are going to allow the customer to order custom quantity of milk (500ml,1000ml,200ml)
- We would like to deliver the order if half of the cost is available in the wallet and mark the remaining as debt (as a good gesture)


- [Developer]Wait, we need some time to speed up 

# Transcript for the video

In this video I'm going to explain single responsibility principle, even though it is a simple one to understand. It is very hard to practice in real life. Let's see what the principal states. As per single responsibility principle. A class or module should have only one responsibility. Should change only for a single reason. Let us look at an example. To understand this principle better. You join a new project, for example, that helps the milkman in daily milk delivery. The software collects the order from each house, and the milkman delivers the order each day. This is the project that you are going to join. Now you are asked implement 2 features. So the features are. we are going to allow the customer to order custom quantity of milk. So something like 500 ml, 1000ml, 2000 200ml and we would like to deliver the order if half of the cost is available in the wallet and mark the remaining as debt as a good gesture sometimes if the wallet runs out of money, then we say we still deliver the order and then maintain some debt and then correct this later. You may be wondering what are these requirements? How to implement them? And how to implement it in a very good fashion? In real life, if you see most of the times will be working on a project which is already running. There is an existing codebase somebody has designed some parts of it and then you are asked to implement new feature or you are asked to fix some bug. And you should ensure that you do this new feature or bugfix in a very clean fashion. Again, this is very easy to say, but very hard to realize in real life. So let's jump into core and see. Basically if you see the program is a small one. So we have roughly some 60 lines of code. Okay, but even this 60 lines of code can be complicated if its what to say it is not written in a proper fashion. So if you look into this class so the task is called a milkman. So if our if you look into the requirements it is a software that helps milkman in delivery right? So they have named classes. Milkman looks fine then we have. Various list of orders. So we see cow milk, goat milk, camel milk. Then there are some chocolate biscuit. So these are all the different orders. Then we have some information regarding wallet balances, how much money the customer has prepaid. Then we have some information regarding price like what is the various Items price and then we have one method which is like a GOD method which takes all this information as a function parameters. And then copies them internally to our internal data structures. Then comes are important function which is to deliver the milk. So basically you see the milk. One takes each order, calculates the price for this order, then checks whether enough money is available in the wallet. If enough money is available, he makes the delivery here. See first he delivers the milk order. Then he delivers chocolate biscuits and other orders actually. If not, he then skips the delivery altogether. And you can see this is a small test run where we create the milkman. We provide the order information and then we deliver the milk . If you see dotnet run why we see yes house zero it made the delivery house two the delivery was made. House 1 I think not enough cash is available so we skip the delivery. Seems to be. Okay. But now when you have to implement this debt logic and also custom things. Basically what you can do is. You can go in the same direction how they have implemented. So for each of these custom. Packet sizes like 500 ml, 200 ml and 1000 ml. You create separate list. You add those parameters here. And then for the debt logic you calculate, you change this information here where if the price is half of the price is available in the wallet then you do the debt calculation and then you complete the things. So this is one way to do. But if you go in this fashion overtime, this class will become completely unmaintainable because. There are too many responsibilities that this single class is handling as of now. But before we jump into. Refactoring this class into something meaningful. Let us also see why we ended up in such a case. So let me go back to. The first version. So this is the first version. Of the software that was released. So if you look into this. So now let's look into the requirements. So the requirements says we would like to help our milkman in delivery. Straight forward requirement, then we have step one. That means the requirement number one is each house. in the street provides the number of milk packs needed. our milk man in the morning delivers the order to each house. if you look into the program. Now you can see. The milkman class is written. There's a list of milk order. The milk order is taken in from outside and then the milkman takes the order list, looks at the order from each house and then makes the delivery This was the initial version which was there. Basically, if you see this class doesn't violate a single responsibility principle in any way. It's clean, neat, and then does everything needed. Now let us go to version 2. Now, if you look into version 2. They added one more requirement. Now that you are delivering 3 different types of milk so they say we are going to. Deliver cow milk, goat milk and soy milk. And houses can choose the milk type. Now, if you look into the program. To implement this requirement, the developer brought in a milk type He changed the milkman class to also take the milk type. For the order and then now there are 2 list which is given. One is the milk count, another one is the milk type. Again, if you see. The milkman delivery logic is simple. He goes into the milk order list, looks at them one by one and he makes the delivery. Again, there is no violation of single responsibility principle here. All looks fine and you can see the. in the dry run and also we have Very simple application as of now. Let's go to iteration 3 now. .so in iteration 3. they say a house can order a combination of milk daily so they say some until now they can choose between either one, but now they can also choose between cow, goat and soya milk. Okay, So what we do? Go and look into the source code, so we removed the milk type now because we know only 3 types of milk we deliver, so we created instead 3 list the cow milk,  goat milk and soy milk. For each order we have a list. Then we take this information in our set order list and deliver milk still does the same thing. It looks at the order one by one and then. whatever combination they have ordered, so the same combination of milk is delivered. Again, this looks to be fine. This no violation of single responsibility principle now. Let us go to Step 4. In step 4 they say we add a new Milk variety called camel milk and then they are saying they are discontinuing the vegan milk now and also we are expanding our business and would like to deliver chocolate and biscuit orders for the with the milk actually. So now if you come if look into the class vacancy in addition to the milk, so we remove the soy milk, we change that to come right now. We also take 2 more list which is for the chocolate and biscuits now. And this method is slowly growing and you can see now there are 5 list that is being taken into these order information.And in the order now we have one row which does the milk delivery and then one row does the Biscuit and chocolate delivery. But we still call this class milkman because the primary responsibility is Milk delivery. Okay, so this is done so now let us go to the next iteration. This is where we stood. So now what we say In step 5 they brought in requirement saying we are switching to a prepaid model now before delivery, the milkman checks whether there is enough money available in the customer wallet, if balance is less than, No delivery is made. So now what we see, we also want to maintain the prepaid balance information. So we add one wallet balances here. We also need to calculate the price for every day, so we also bring the price information into this class. So we need the price information and then we take this information from outside. That means we take the wallet information also has a part of our order and then in the delivery milk. Now what we do? we calculate the price. That means for each order, what is the price? And then we check if there is enough money in the balance. Then we make the delivery or just the balance in the valid. If not then we say not enough cash to buy the order and then we stop here.So if you see, Now the class came to the state where we started. Basically, from the initial version we came here one step at a time, and then there was only one list. Then we added one more list, then we added one more list, then we added 2 more list. Then we are one more list and then there was a price information. So we added this price information here. Then we thought each time we added one parameter it is not like we day one. We created that and we put all these things in. Then we looking to deliver milk and then we saw that we also need to do this prepaid logic. So we implemented the prepaid logic also here now. and, finally, what we did? this dryrun also has been changed to accommodate all these changes now, so basically this is how the whole complexity comes in, so it is not like we write the complex code on day one. Each time a small delta amount of complexity comes in, which we can still consume. So we bring the complexity into our code and then we add this to this code complexity. But overtime what happens? If a new person comes for them, it may look completely out of place and then it becomes really hard to maintain such code base. So there comes a time when you decide that I have to refactor things. And do some changes. So now if you see this code looks quite hard. There's a god method why we have wallet here? Why Milkman is delivering biscuits? Why price info here? They're like this. There are so many questions that come to a new developer who joined this project. So before we jump into code and then implement these 2 new features, we refactor this code. Into something manageable. If you look in. Currently the responsibilities. This class has responsibilities for delivery, it has responsibilities regarding price. It has responsibilities to maintain order. It has responsibilities regarding wallet. All these informal responsibilities are there together in one single class. So what we do? we try to refactor them into separate entities. so price is a separate one. Wallet is separate. Order is a separate one and delivery is a separate. Let's see how this can be done in the code. Let me check out. Let me open the old code actually. This is the code that we are having in iteration previous iteration. So basically first what we look and see is there is a lot of information regarding order. So let us refactor this order into a separate class. So what we do? Create a class called order and if you see whenever we do refactoring, we create each class in its own separate file. The reason is we don't have much distraction. The order file only talks about order. and other things we don't get to see in this class. So in order has 2 information, the item and the quantity. It maintains a dictionary for that and for an order. If you give the price list it can calculate and return the price. And also when you want to print an order, it provides a utility method toString() which can print this order in a nice fashion. Next, if you see. We have some wallet balances which is customer wallet and wallet related information. So let us carve this out into a separate class called wallet. So in the wallet we have 2 information what is the current balance and what is the debt. So initially some amount is provided to start with an whenever the customer adds money to the wallet, we adjust the current balance and also if there is a debt then we adjust the debt also and then ensure that the balance is always reflecting the current amount. And whenever you need to take some payment, for example from this wallet the If the balance is fine with respect to the order, then we just do the calculation that it's okay if, for example, the balance is less then we do this debt logic here. We tend to do we do is. We say we if there is half the amount is available in the wallet then we try to. we still allow the payment to go through. If not then we say okay, they wallet does not allow you. There is no enough money and then the payment fails. Now, if you look into the 3rd thing, we have some information regarding the price. So you can see. Various price is maintained here, so we try to carve this out into a separate file. Under class called price list and price list. Normally we would load this information from some kind of a database, but here for the sake of simplicity, I am loading it here in the class itself hard coded, if you see we create a dictionary for each of the item we have the price listed here and if you give an item name then it can find the price for item and it will return price so this class takes care of all the price list related information. now let us see how Milkman looks now. So from here the same milkman class is refracted into Milkman here, so we have a list of order. We have some price list and we have some wallet balance, so the milkman takes all this information everyday. That means what is the current order? What is the current price list and what is the wallet information of the customer? Then when the milk, deliver should happen. Basically he takes each order. He calculates the price and then he checks whether he can get the payment for the price or not, if he can get the payment, then he says he makes the delivery. If not, then he says not enough cash to buy the order and then he skips the delivery. So this class looks much more clean and easy to understand and also now whenever a new logic has to be implemented, For example when you have to implement this different qualities of milk, all that you need to do is you have to goto price list. Add this new quantities here for example cowmilk_200ml and then put a price and order anyway will take care of generic item not so there is no individual list anymore so it can take any mixed order now. And the milkman class looks much simple and clear and there is only one responsibility which is still order delivery. But taking all this information, if you see each of the respective other responsibilities are moved to the respective classes. And finally, if you look at the program, you can see we have a list of order. Then we have a list of wallet info. We create a price list and then we just say deliver milk and this code looks much more clean and neat .So basically we started from monolithic class and then slowly refactored into individual responsibilities Now, once you have things like this again, you will start to get new requirements and then you will implement requirements one by one in each of these classes. Again, overtime they will become complex and then you have to redo the same refactoring. Ensure that the responsibilities are clearly separated. That way it will be easy for you to develop and implement new features and also keep the complexity under check. Thanks for the time and see you in some other video later.